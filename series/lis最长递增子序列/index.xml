<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LIS最长递增子序列 on Ryan&#39;s blog</title>
    <link>https://ryanyux.github.io/series/lis%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link>
    <description>Recent content in LIS最长递增子序列 on Ryan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copy, _right?_ :thinking_face:</copyright>
    <lastBuildDate>Mon, 04 Sep 2023 14:56:44 +0800</lastBuildDate><atom:link href="https://ryanyux.github.io/series/lis%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>俄罗斯套娃信封问题</title>
      <link>https://ryanyux.github.io/posts/leetcode/354/</link>
      <pubDate>Mon, 04 Sep 2023 14:56:44 +0800</pubDate>
      
      <guid>https://ryanyux.github.io/posts/leetcode/354/</guid>
      <description>显然该问题是一个最长增子序列, 不过和 不同的是:1、 本问题中的信封不一定要套前面那个信封.</description>
      
    </item>
    
    <item>
      <title>最长递增子序列</title>
      <link>https://ryanyux.github.io/posts/leetcode/300/</link>
      <pubDate>Mon, 04 Sep 2023 13:56:44 +0800</pubDate>
      
      <guid>https://ryanyux.github.io/posts/leetcode/300/</guid>
      <description>O(n^2)方法 # 对于第i个元素, 我们可以遍历其前面的所有数, 然后找到比nums[i]小的数nums[j], 然后比较把nums[i]放在nums[j]之后的序列会不会更长一点.</description>
      
    </item>
    
  </channel>
</rss>
